# ADR-003: ポイント付与機能におけるドメインモデルの責任分離とレイヤー構造の標準化

- **Status:** Accepted
- **Date:** 2025-12-03

## Context

**事実の改竄のリスク** `fact=policy.enforce(fact)`という実装により、過去の事実が計算過程で書き換わるという意味論的なねじれが発生した。
**リポジトリの責務混合** `repository.save(fact)`という呼び出しにより、入力データである事実を保存するのか、計算過程を保存するのかが曖昧になり、リポジトリ内で隠れた計算ロジックが必要になる懸念があった。
**サービスの配置基準** ドメイン層とアプリケーション層のどちらに Service を置くべきか、その粒度や役割分担(ビジネスルール vs アプリの都合)の基準が不明瞭だった

## Decision

### 1. ドメインモデリングの Input/Output 分離

**変更:** `Fact`(Input/不変)と`PointEntry`(Output/結果)を明確に別クラスとして定義する
**処理フロー:** Policy は`calculate(fact):PointEntry`という副作用のない計算として定義して、変数の再代入を行わない
**保存対象:** リポジトリは`save(pointEntry)`のみを受け入れる。 Fact(ItemID 配列など)の正規化・保存は Fact 発生元の別リポジトリの責務として、本リポジトリ(pointEntry)では扱わない

### 2. 情報粒度によるレイヤー定義の採用

ドメイン層とアプリケーション層を、情報の「粒度(大・中・小)」で対称的に整理する。

**Domain 層(ビジネス理解)**
**大(Service)** 業務プロセス。例：`PointGrantService` 複数のルールを束ねる
**中(Policy/Repository Contract)** 計算ロジック 例：`PointPolicy` およびリポジトリ IF
**小(Entity/VO)** データと振る舞い 例：`PointEntry`

**Application 層(クライアント要求)**
**大(UseCase)** 進行役。例:`GrantPointUseCase` Tx 管理や手順
**中(Port Contract)** 例:`IEmailNotifier`
**小(DTO)** 入出力データ

## Consequences

**Positive**
**責務の明確化** 事実と結果が型レベルで分かれたため、誤ったデータの書き換えや保存を防止
**共通言語の確立** レイヤー内の大中小の基準が出来たことで、このロジックはどこに置くかの判別がわかりやすくなった
**Negative**
**初期実装コスト** 単純な CRUD であっても、必要なファイルが多くなる。そのため ROI が高い機能かどうか、チームの技術力アップの向上に繋がるかなど、多角的な視野で総合的に判定して、クリーンアーキテクチャを実装する程度を決定したほうが良い
