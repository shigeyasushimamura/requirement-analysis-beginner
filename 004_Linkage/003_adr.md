# ADR-004: 求人マッチングにおける検索アーキテクチャとモデル設計

- **Status:** Accepted
- **Date:** 2025-12-08

# Context

- ビジネス要件:
  - 求職者データ(数百万件規模)に対し、採用担当者が設定した「ターゲット条件」に基づいて候補者を検索したい
  - 検索条件を変更した際、リアルタイム(500 ミリ秒以内)に結果が再計算・再描画される非機能要件が、ユーザの UX 体験のために欲しい
- 技術的課題:
  - 検索条件は「必須(Must)」によるフィルタリングと、「歓迎(Want)」による**重み付きスコアリング**の組み合わせである
  - RDB の標準的なインデックスは「絞り込み(Filtering)」には強いが、「全候補者に対する動的な点数計算とソート」は計算コストが高く、データ量に比例してレスポンスが悪化する

# Condidered Altenatives

1. PostgreSQL(JSONB + GIN Index)のみ

- 概要：`OfferingRequirements`を JSON として扱い、GIN インデックスで検索する
- Pros:
  - インフラ構成がシンプル(RDB のみ)。データ整合性の担保が有利
  - Must 条件(フィルタリング)のみであれば、GIN インデックスにより、高速に動作する
- Cons:
  - スコアリングの壁: フィルタリングの後のヒット件数が数万件になった場合、その全レコードに対して「Want 条件」の加点計算(CPU 処理)とソート(メモリ処理)が発生する。これにより応答時間が数百ミリ秒～数秒に劣化して、非機能要件(リアルタイム性)を満たせない
  - 複合条件のインデックス設計が困難であり、将来的な「あいまい検索」への対応も弱い
  - スケールコスト: データ量が増えた際、CPU リソースを大量に消費する

2. ElasticSearch/OpenSearch 導入

- 概要: 書き込みは RDB,読み込みは検索エンジンに行わせる(CQRS)
- Pros:
  - 転置インデックスとスコアリング: 転置インデックスの統計情報を利用することで、実データを全件スキャンすることなく高速にスコア計算とランキングが可能になる。数百万件規模でも安定的に数十ミリ秒で応答できる
  - 柔軟性:「AWS ができれば+10 点」といったビジネスルールをクエリ DSL(bool/should/boost)として直感的に表現できる
  - パフォーマンス: 転置インデックスは、検索対象文書をトークンごとに逆引きで保持するため、検索時の探索空間を大幅に削減できる。また、この構造はシャーディングによる分散処理と相性が良く、大規模な並列検索が可能になる。
- Cons:
  - システム構成が複雑になる(同期パイプラインが必要)

# Decision

**ElasticSearch の採用** :
ユーザ体験(レイテンシ)とスケーラビリティを最優先して、検索エンジンを導入する

**通信コストの抑制策**:

- クライアント側で全データをキャッシュ・処理することはセキュリティとパケット量の関係で禁止する。代わりに UI 側で Debounce 処理(入力完了後のみリクエストを投げる)を行い、過剰なリクエストを防止する

# 結果

- Positive: ユーザ数・データ数が増加しても、検索速度を一定に保てるアーキテクチャとなった
- Negative: RDB と検索エンジンのデータ不整合(同期漏れ)を検知・復旧する仕組みを別途検討する必要がある
