## 5-A. ストレージ戦略：RDB Sharding & Partitioning

146TB を RDB で扱う場合、単一のインスタンスでは物理限界（I/O やバックアップの肥大化）に達します。  
そのため、以下の **「ハイブリッド・パーティショニング」** を提案します。

### Sharding（水平分割）

- **ShipmentID** をシャードキーとして、データベースを複数台に分散
- ピーク時の Write / Read 負荷を分散可能

### Partitioning（時間軸分割）

- 各シャード内で **月単位のパーティション** を作成

### データ温度別配置

- **Hot Data**
  - 直近 1〜3 ヶ月のデータ（配送中・最近完了）
  - 高速な SSD に配置
- **Cold Data**
  - 3 ヶ月以上経過したデータ
  - 低コストストレージ、または **S3 / BigQuery** へアーカイブ

### 分析要件（OLAP）

- ビジネス分析用途については、
  - RDB の **Read Replica** から
  - **ETL ツール** を用いて
  - **OLAP（BigQuery 等）** に同期
- 本番 DB のパフォーマンスを落とさずに、複雑な分析クエリを実行可能

---

## 5-B. 読み込み負荷と Outbox パターンの適用

「クライアント側のキャッシュ」と  
「Outbox パターンによるプッシュ配信」を組み合わせた構成。

### 1. Transactional Outbox Pattern の役割

- **Atomicity**

  - Shipment のステータス更新と
  - EventLog（Outbox テーブル）への書き込みを
  - **同一トランザクション** で実行

- **Reliability**

  - 更新と同時に Outbox テーブルへメッセージを記録
  - 別プロセスの **Message Relayer** が
    - Kafka / RabbitMQ 等へ確実にパブリッシュ

- **DIP（依存性逆転の原則）の遵守**
  - ドメイン層は「外部通知」のインフラ詳細を知らない
  - 単に **ドメインイベントを発行** するだけでよい

### 2. クライアントキャッシュと同期（Push vs Pull）

#### Push（WebSocket / SSE）

- 配達員アプリ
- 荷主の管理画面
- **「常に画面を開いている」アクター** に対して有効

#### Problem

- 受取人（一般ユーザー）は **数百万〜数千万規模**
- 全端末のキャッシュを Outbox 経由でリアルタイム更新すると、
  - ネットワークコストが過大
  - プッシュ通知サーバーの負荷が極端に増大

#### Solution

- **CDN / Edge Cache**

  - 一般公開の追跡ページ（Read の大部分）
  - 追跡番号をキーに
  - **CDN（CloudFront / Akamai）**
  - TTL は **10〜30 秒程度の短期キャッシュ**

- **Redis**
  - API サーバーの直前に配置
  - 頻繁にアクセスされる
    - 「配送中」の荷物データ
  - をインメモリキャッシュ

## CDN と Redis と API の使分け

### 1. なぜ「動的なデータ」を CDN に置くのか？

通常、荷物の追跡ステータスは数秒おきに変わるものではありません。  
しかし実際には、以下のようなアクセス特性があります。

- 受取人が「今どこかな？」と **ブラウザをリロード（連打）** する
- SNS 等で共有され、**同じ追跡番号に短時間でアクセスが集中** する

#### 静的ページの配布ではない点が重要

- 追跡番号 `1234-5678` に対するリクエストに対し、
  - API が返した **最新の配送ステータス（JSON 等）** を
  - CDN が **「30 秒間だけ」キャッシュ** する

#### メリット

- 次に同じ追跡番号を見に来た別のユーザー
- あるいは同じユーザーの再読み込み

これらに対して、  
**API サーバーまでリクエストを飛ばさず、CDN が即座にレスポンス** を返せます。

結果として、

- バックエンド（API / Redis / DB）へのアクセスが激減
- 瞬間的なトラフィック集中にも耐えられる

という効果が得られます。

---

### 2. Redis や API（オリジン）にアクセスするのはどんな時か？

CDN を通り抜け、その奥にある Redis や API にアクセスが発生するのは、
主に次の 4 ケースです。

#### ① キャッシュミス（初回アクセス）

- その追跡番号がしばらく誰にも検索されていない
- CDN に該当データが存在しない場合

#### ② TTL（有効期限）切れ

- CDN に保存されたデータの TTL（例：30 秒）が切れた後
- 最初のアクセスが **最新状態を取得するために API へ到達**

#### ③ 書き込み操作（POST / PUT）

- 「再配達を依頼する」
- 「受け取り場所を変更する」

といった **データ更新系操作** はキャッシュ不可のため、
必ず API → Redis / DB まで到達します。

#### ④ パーソナライズされた情報

- マイページ
- 住所録
- 通知設定 など

ログインユーザーごとに内容が異なる画面は、

- セキュリティ
- 個別性

の観点から CDN で一律キャッシュせず、
Redis や API から直接取得します。

---

### 3. 全体のデータフロー図（論理イメージ）

リクエストが **どこで止まり、どこまで到達するか** を整理すると以下の通りです。

| レイヤー        | 役割                                   | キャッシュ / データ内容                              |
| --------------- | -------------------------------------- | ---------------------------------------------------- |
| **CDN（Edge）** | 大量アクセスの防波堤                   | 追跡番号ごとの最新ステータス（短期間）               |
| **Redis**       | 高速なデータ読み書き                   | 「配送中」の荷物、頻繁に参照されるユーザーセッション |
| **API / DB**    | データの真実（Single Source of Truth） | 全履歴、ユーザー情報、契約情報                       |

---

### まとめ：使い分けの基準

- **CDN**

  - 「誰が見ても同じ（公開情報）」
  - かつ「読み取り専用」
  - アクセス集中からバックエンドを守る

- **Redis**

  - 「高頻度で更新・参照される」
  - かつ「API 側ですぐに計算・取得したい」データ

- **API / DB**
  - 「絶対に失われてはいけない」
  - かつ「複雑なビジネスロジックを伴う」処理

このように、  
**「データの鮮度」×「アクセスの集中度」** によって  
どこでデータを返すかを切り分けるのが、モダンなアーキテクチャ設計の定石です。

以下は、**「API を作り、CDN を前段に置いて運用する」** 際の  
**実務での鉄板ステップ**を、**設計 → 実装 → 配置 → 運用** の順で整理したものです。  
この手順どおり進めれば、まず失敗しません。

---

## IDOR とは何か

IDOR（Insecure Direct Object Reference） とは、

> 認可（Authorization）チェックが不十分なまま、
> URL やリクエストパラメータで指定された「オブジェクト ID」を
> 直接参照できてしまう脆弱性

典型例：

```http
GET /api/delivery/12345
Authorization: Bearer userA-token
```

- 12345 が 連番
- サーバ側が「この配送情報が 誰のものか」を検証していない

結果として：

```http
GET /api/delivery/12346
```

と叩くだけで 他人の配送情報が取得できる

### セキュリティ設計の精緻化

1. IDOR 対策と認証・認可の階層化
   ご提案の「中継地点のみ表示」は、不特定多数がアクセスする「公開追跡ページ」には最適です。しかし、ビジネス要件として「受取人本人には詳細（住所等）を見せたい」という要望が必ず出ます。

- Public Access: 追跡番号のみ。表示は「都市名・支店名・ステータス」に限定。

- Authorized Access: 荷主(Sender)や受取人(Recipient)。認証（ログイン）または、非推測的なトークン（Signed URL/UUID） を含むリンクからアクセスした場合のみ、詳細な住所や氏名を表示。

- 技術的対策: ShipmentID に連番（1001, 1002...）を使わず、UUID v4 または HashID を使用し、攻撃者が「次の番号」を推測できないようにします。

2. イベントログの不変性（Immutability）の担保
   「Update/Delete 禁止・追記のみ」は基本ですが、管理者権限を持つ内部人間による DB の直接書き換えというリスク（内部不正）が残ります。

- Digital Signatures (デジタル署名): イベント発生時（例：配達員の端末）で、EventPayload + Timestamp + SequenceNumber を秘密鍵で署名し、その署名をログに含めます。これにより、後から DB の中身を書き換えても署名検証で「改ざん」を検知できます。
  - アプリケーション層で暗号化するかどうか
  - インフラ層でどうやって暗号化するか
